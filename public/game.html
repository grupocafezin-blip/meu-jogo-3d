<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<title>Clique na Cor Certa ‚Äî Vers√£o Final com N√≠veis</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#111;--panel:#1a1a1a;--text:#eee}
  body{margin:0;height:100vh;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Arial;text-align:center;overflow:hidden}
  #telaInicio{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#0b0b0b99,#000000cc);z-index:50}
  .card{background:var(--panel);padding:20px;border-radius:12px;box-shadow:0 8px 30px #00000088;min-width:280px}
  input,select,button{font-size:16px;padding:8px;margin-top:8px;width:100%;box-sizing:border-box;border-radius:6px;border:1px solid #333;background:#0f0f0f;color:var(--text)}
  button{cursor:pointer}
  #hud{position:fixed;top:10px;left:10px;z-index:40;text-align:left}
  #hud div{background:#111;padding:8px 12px;border-radius:8px;margin-bottom:6px;border:1px solid #222}
  canvas{display:block;margin:0 auto;background:linear-gradient(#0b0b0b,#070707);touch-action:none}
  /* joystick virtual */
  #joystick{position:fixed;bottom:20px;left:20px;width:110px;height:110px;border-radius:50%;background:rgba(255,255,255,0.06);display:none;z-index:40;touch-action:none}
  #joystick .stick{position:absolute;width:46px;height:46px;border-radius:50%;left:32px;top:32px;background:rgba(255,255,255,0.14);pointer-events:none;transition:transform 0.02s}
  /* small helper */
  #status{position:fixed;right:10px;top:10px;background:#111;padding:8px;border-radius:8px;border:1px solid #222}
</style>
</head>
<body>

<!-- Tela inicial -->
<div id="telaInicio">
  <div class="card">
    <h2>üéØ Clique na Cor Certa</h2>
    <input id="nomeJogador" placeholder="Digite seu nome" />
    <label style="display:block;margin-top:8px;text-align:left;font-size:14px;color:#bbb">Cor do personagem</label>
    <select id="corJogador">
      <option value="white">Branco</option>
      <option value="red">Vermelho</option>
      <option value="blue">Azul</option>
      <option value="green">Verde</option>
      <option value="yellow">Amarelo</option>
      <option value="purple">Roxo</option>
      <option value="orange">Laranja</option>
    </select>
    <label style="display:block;margin-top:8px;text-align:left;font-size:14px;color:#bbb">Modo</label>
    <select id="modoTela">
      <option value="fixed">Tamanho fixo (800√ó600)</option>
      <option value="full">Tela cheia responsiva (melhor para celular)</option>
    </select>
    <p style="color:#aaa;font-size:13px;margin:8px 0">Use teclado, joystick f√≠sico ou o joystick virtual (no celular aparece automaticamente).</p>
    <button id="btnStart">Come√ßar</button>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div id="placar">Pontua√ß√£o: 0 | Vidas: 3</div>
  <div id="infoNivel">N√≠vel: 1 | Tempo: 0s</div>
</div>
<div id="status"></div>

<!-- Canvas -->
<canvas id="gameCanvas" width="800" height="600"></canvas>

<!-- Joystick virtual -->
<div id="joystick"><div class="stick"></div></div>

<script>
/* -----------------------------
   Configur√°veis
   ----------------------------- */
const START_LIVES = 6;
const LEVEL_DURATION = 20; // segundos por n√≠vel (aumenta a cada n√≠vel)
const BASE_ENEMY_COUNT = 1; // inimigos iniciais
const BASE_WALLS = 1; // paredes iniciais
const WALL_GROW_PER_LEVEL = 1; // paredes adicionais por n√≠vel
const ENEMY_GROW_PER_LEVEL = 1; // inimigos a mais por n√≠vel (ou uso para escala)
const PROJECTILE_LEVEL_THRESHOLD = 3; // a partir desse n√≠vel inimigos podem atirar
const CANVAS_W = 800;
const CANVAS_H = 600;

/* -----------------------------
   Setup elementos e vari√°veis
   ----------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const telaInicio = document.getElementById('telaInicio');
const btnStart = document.getElementById('btnStart');
const nomeInput = document.getElementById('nomeJogador');
const corSelect = document.getElementById('corJogador');
const modoTela = document.getElementById('modoTela');
const placarEl = document.getElementById('placar');
const infoNivelEl = document.getElementById('infoNivel');
const statusEl = document.getElementById('status');

const joystickEl = document.getElementById('joystick');
const stickEl = joystickEl.querySelector('.stick');

/* Ajuste de canvas para modo responsivo se pedido */
function setCanvasMode(mode){
  if(mode === 'full'){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  } else {
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;
  }
}
setCanvasMode('fixed');
window.addEventListener('resize', ()=> {
  if(modoTela.value === 'full') setCanvasMode('full');
});

/* -----------------------------
   Estado do jogo
   ----------------------------- */
let player = { x:400, y:300, r:18, speed:4, color:'white', name:'Jogador' };
let bolas = []; // bolinhas coloridas (6)
const CORES = [
  {nome:'vermelho', cor:'red'},
  {nome:'azul', cor:'blue'},
  {nome:'verde', cor:'green'},
  {nome:'amarelo', cor:'yellow'},
  {nome:'roxo', cor:'purple'},
  {nome:'laranja', cor:'orange'}
];
let corAlvo = null;
let score = 0;
let lives = START_LIVES;

/* Level & difficulty */
let level = 1;
let levelStartTime = 0;
let walls = []; // rect walls {x,y,w,h}
let enemies = []; // enemy {x,y,r,dx,dy,speed,canShoot,shootCooldown}
let projectiles = []; // {x,y,r,dx,dy,owner}
let joystickIndex = null;
let usingVirtualJoystick = false;

/* Input */
let keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);
/* Gamepad connect/disconnect */
window.addEventListener('gamepadconnected', e => {
  joystickIndex = e.gamepad.index;
  statusEl.innerText = `Gamepad conectado: ${e.gamepad.id}`;
});
window.addEventListener('gamepaddisconnected', e => {
  joystickIndex = null;
  statusEl.innerText = '';
});

/* Virtual joystick state */
let touchId = null;
let touchMove = {x:0,y:0};

/* -----------------------------
   Utilit√°rios de colis√£o
   ----------------------------- */

// circle-rect collision test (does circle intersect rect)
function circleRectColliding(cx,cy,cr, rx,ry,rw,rh){
  const nearestX = Math.max(rx, Math.min(cx, rx+rw));
  const nearestY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - nearestX;
  const dy = cy - nearestY;
  return (dx*dx + dy*dy) < (cr*cr);
}

// resolve circle vs rect by pushing circle out along shortest axis
function resolveCircleRect(circle, rect){
  // if not colliding, return false
  if(!circleRectColliding(circle.x,circle.y,circle.r, rect.x,rect.y,rect.w,rect.h)) return false;
  // find nearest point
  const nearestX = Math.max(rect.x, Math.min(circle.x, rect.x+rect.w));
  const nearestY = Math.max(rect.y, Math.min(circle.y, rect.y+rect.h));
  let dx = circle.x - nearestX;
  let dy = circle.y - nearestY;
  let dist2 = dx*dx + dy*dy;
  if(dist2 === 0){
    // circle center exactly at corner or inside; push out upward
    dy = -1; dx = 0; dist2 = 1;
  }
  const dist = Math.sqrt(dist2);
  const overlap = circle.r - dist;
  if(overlap > 0){
    // normalize
    dx /= dist; dy /= dist;
    circle.x += dx * overlap;
    circle.y += dy * overlap;
    return true;
  }
  return false;
}

// rect-rect collision
function rectsOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

/* -----------------------------
   Procedural walls generator (simple incremental)
   ----------------------------- */

function generateWallsForLevel(lvl){
  const desired = BASE_WALLS + Math.floor((lvl-1) * WALL_GROW_PER_LEVEL);
  const result = [];
  const attemptsMax = 200;
  let attempts = 0;
  while(result.length < desired && attempts++ < attemptsMax){
    // create random rectangle size scaled with canvas
    const w = 60 + Math.random()*160;
    const h = 40 + Math.random()*120;
    const x = Math.random() * (canvas.width - w - 20) + 10;
    const y = Math.random() * (canvas.height - h - 20) + 10;
    const rect = {x,y,w,h};
    // avoid placing rect too close to player start center
    const playerStartDist = Math.hypot(x + w/2 - canvas.width/2, y + h/2 - canvas.height/2);
    if(playerStartDist < 100) continue;
    // avoid overlap with other walls
    let ok = true;
    for(const r of result) { if(rectsOverlap(r, rect)) { ok=false; break; } }
    if(!ok) continue;
    // ensure not occupying center-ish whole area or too big
    result.push(rect);
  }
  // guarantee boundary walls around edges (thin)
  // optional: keep borders by geometry, but here canvas edges suffice
  return result;
}

/* -----------------------------
   Entities creation
   ----------------------------- */

function spawnBolas(){
  bolas = [];
  // spawn 6 colored balls (one each)
  const shuffled = [...CORES].sort(()=>Math.random()-0.5);
  shuffled.forEach((c,i)=>{
    // find a free position not inside wall
    let tries = 0;
    while(tries++ < 200){
      const r = 16;
      const x = Math.random()*(canvas.width - 2*r) + r;
      const y = Math.random()*(canvas.height - 2*r) + r;
      const ball = {x,y,r,cor:c.cor,nome:c.nome,dx:(Math.random()*2-1)*1.6,dy:(Math.random()*2-1)*1.6};
      // ensure not colliding with wall
      let bad=false;
      for(const w of walls){ if(circleRectColliding(ball.x,ball.y,ball.r,w.x,w.y,w.w,w.h)) { bad=true; break; } }
      if(!bad){
        bolas.push(ball); break;
      }
    }
  });
  // choose target color
  corAlvo = CORES[Math.floor(Math.random()*CORES.length)];
  updateInstruction();
}

/* spawn enemies according to level */
function spawnEnemiesForLevel(lvl){
  enemies = [];
  const count = BASE_ENEMY_COUNT + Math.floor((lvl-1) * 0.5); // scale slower
  const speedBase = 1.0 + (lvl-1) * 0.25;
  let tries=0;
  for(let i=0;i<count && tries<400;i++){
    tries++;
    const r = 14;
    const x = Math.random()*(canvas.width-2*r)+r;
    const y = Math.random()*(canvas.height-2*r)+r;
    const enemy = {
      x,y,r,
      dx:(Math.random()*2-1),
      dy:(Math.random()*2-1),
      speed: speedBase + Math.random()*0.6,
      canShoot: lvl >= PROJECTILE_LEVEL_THRESHOLD && Math.random() < Math.min(0.6, (lvl- (PROJECTILE_LEVEL_THRESHOLD-1))*0.25),
      shootCooldown: 1 + Math.random()*2,
      shootTimer: 0
    };
    // ensure not in walls or overlapping player or balls
    let bad=false;
    for(const w of walls) if(circleRectColliding(enemy.x,enemy.y,enemy.r,w.x,w.y,w.w,w.h)) { bad=true; break; }
    if(bad) { i--; continue; }
    enemies.push(enemy);
  }
}

/* -----------------------------
   Level progression management
   ----------------------------- */

function startLevel(lvl){
  level = lvl;
  levelStartTime = performance.now();
  // generate walls
  walls = generateWallsForLevel(lvl);
  // spawn balls & enemies
  spawnBolas();
  spawnEnemiesForLevel(lvl);
}

/* -----------------------------
   Gameplay helpers
   ----------------------------- */

function updateInstruction(){
  // show target color in HUD (we'll show in status)
  statusEl.innerText = `Toque na cor: ${corAlvo? corAlvo.nome : '---'}`;
}

function resetGame(){
  score = 0;
  lives = START_LIVES;
  player.x = canvas.width/2;
  player.y = canvas.height/2;
  startLevel(1);
  updateHUD();
}

/* -----------------------------
   Movement & physics step
   ----------------------------- */

function movePlayer(dt){
  // keyboard
  if(keys['ArrowUp']||keys['w']) player.y -= player.speed;
  if(keys['ArrowDown']||keys['s']) player.y += player.speed;
  if(keys['ArrowLeft']||keys['a']) player.x -= player.speed;
  if(keys['ArrowRight']||keys['d']) player.x += player.speed;
  // gamepad
  if(joystickIndex!==null){
    const gp = navigator.getGamepads()[joystickIndex];
    if(gp){
      const dead = 0.2;
      const ax = gp.axes[0];
      const ay = gp.axes[1];
      if(Math.abs(ax)>dead) player.x += ax * player.speed;
      if(Math.abs(ay)>dead) player.y += ay * player.speed;
    }
  }
  // virtual joystick
  player.x += touchMove.x * player.speed * 1.2;
  player.y += touchMove.y * player.speed * 1.2;

  // bounds
  if(player.x - player.r < 0) player.x = player.r;
  if(player.x + player.r > canvas.width) player.x = canvas.width - player.r;
  if(player.y - player.r < 0) player.y = player.r;
  if(player.y + player.r > canvas.height) player.y = canvas.height - player.r;

  // wall collisions -- resolve
  for(const w of walls) resolveCircleRect(player, {x:w.x,y:w.y,r:0,w:w.w,h:w.h});
}

function moveBalls(dt){
  bolas.forEach(b=>{
    b.x += b.dx;
    b.y += b.dy;
    // bounds reflect
    if(b.x - b.r < 0){ b.x = b.r; b.dx *= -1; }
    if(b.x + b.r > canvas.width){ b.x = canvas.width - b.r; b.dx *= -1; }
    if(b.y - b.r < 0){ b.y = b.r; b.dy *= -1; }
    if(b.y + b.r > canvas.height){ b.y = canvas.height - b.r; b.dy *= -1; }
    // wall collisions: bounce by simple rejection
    for(const w of walls){
      if(circleRectColliding(b.x,b.y,b.r,w.x,w.y,w.w,w.h)){
        // simple bounce: if center x within wall.x..wall.x+w then invert dy else invert dx
        if(b.x > w.x && b.x < w.x + w.w) b.dy *= -1;
        else b.dx *= -1;
        // nudge out a bit
        b.x += b.dx * 2;
        b.y += b.dy * 2;
      }
    }
  });
}

function moveEnemies(dt){
  enemies.forEach(en=>{
    // basic movement
    en.x += en.dx * en.speed;
    en.y += en.dy * en.speed;

    // wall collision: if collides, reverse direction and nudge back
    for(const w of walls){
      if(circleRectColliding(en.x,en.y,en.r,w.x,w.y,w.w,w.h)){
        // revert step
        en.x -= en.dx * en.speed;
        en.y -= en.dy * en.speed;
        // choose new random direction away from wall
        en.dx = (Math.random()*2-1);
        en.dy = (Math.random()*2-1);
        // normalize
        const mag = Math.hypot(en.dx,en.dy) || 1;
        en.dx /= mag; en.dy /= mag;
      }
    }
    // bounds bounce
    if(en.x - en.r < 0){ en.x = en.r; en.dx *= -1; }
    if(en.x + en.r > canvas.width){ en.x = canvas.width - en.r; en.dx *= -1; }
    if(en.y - en.r < 0){ en.y = en.r; en.dy *= -1; }
    if(en.y + en.r > canvas.height){ en.y = canvas.height - en.r; en.dy *= -1; }

    // shooting
    if(en.canShoot){
      en.shootTimer -= dt;
      if(en.shootTimer <= 0){
        en.shootTimer = en.shootCooldown + Math.random()*1.5;
        spawnProjectileFromEnemy(en);
      }
    }
  });
}

/* -----------------------------
   Projectiles
   ----------------------------- */
function spawnProjectileFromEnemy(en){
  const speed = 3 + level*0.3;
  const angle = Math.atan2(player.y - en.y, player.x - en.x);
  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;
  projectiles.push({x:en.x, y:en.y, r:5, dx:vx, dy:vy, owner:'enemy'});
}

function moveProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    p.x += p.dx;
    p.y += p.dy;
    // remove if off-screen
    if(p.x < -20 || p.x > canvas.width+20 || p.y < -20 || p.y > canvas.height+20){ projectiles.splice(i,1); continue; }
    // collide with walls -> destroy
    let hitWall=false;
    for(const w of walls) if(circleRectColliding(p.x,p.y,p.r,w.x,w.y,w.w,w.h)){ hitWall=true; break; }
    if(hitWall){ projectiles.splice(i,1); continue; }
  }
}

/* -----------------------------
   Collisions between player, balls, enemies, projectiles
   ----------------------------- */

function handleCollisions(){
  // player vs balls (original mechanic)
  for(const b of bolas){
    const d = Math.hypot(player.x - b.x, player.y - b.y);
    if(d < player.r + b.r){
      if(b.nome === corAlvo.nome){
        score++;
        // small feedback: push ball away
        b.dx *= -1.2; b.dy *= -1.2;
      } else {
        lives--;
        // knockback
        const ang = Math.atan2(b.y - player.y, b.x - player.x);
        player.x -= Math.cos(ang)*20;
        player.y -= Math.sin(ang)*20;
      }
      updateHUD();
      if(lives <= 0){ gameOver(); return; }
      // next round: new balls and color target
      spawnBolas();
      break; // prevent multiple collisions same frame
    }
  }

  // player vs enemies
  for(const en of enemies){
    const d = Math.hypot(player.x - en.x, player.y - en.y);
    if(d < player.r + en.r){
      lives--;
      updateHUD();
      // push player back
      const ang = Math.atan2(player.y - en.y, player.x - en.x);
      player.x += Math.cos(ang)*30;
      player.y += Math.sin(ang)*30;
      if(lives <= 0){ gameOver(); return; }
      // small reaction: enemy bounces
      en.dx *= -1; en.dy *= -1;
    }
  }

  // projectiles vs player
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    const d = Math.hypot(player.x - p.x, player.y - p.y);
    if(d < player.r + p.r){
      lives--;
      projectiles.splice(i,1);
      updateHUD();
      if(lives <= 0){ gameOver(); return; }
    }
  }

  // projectiles vs enemies (friendly fire not implemented but could)
}

/* -----------------------------
   HUD & game over
   ----------------------------- */
function updateHUD(){
  placarEl.innerText = `Pontua√ß√£o: ${score} | Vidas: ${lives}`;
  const tsec = Math.floor((performance.now() - levelStartTime)/1000);
  infoNivelEl.innerText = `N√≠vel: ${level} | Tempo: ${tsec}s`;
  updateInstruction();
}

function gameOver(){
  alert(`${player.name} ‚Äî Game Over!\nPontua√ß√£o: ${score}\nReiniciando...`);
  // reset
  startLevel(1);
  score = 0;
  lives = START_LIVES;
  player.x = canvas.width/2; player.y = canvas.height/2;
  updateHUD();
}

/* -----------------------------
   Drawing
   ----------------------------- */
function draw(){
  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw walls
  ctx.fillStyle = '#222';
  ctx.strokeStyle = '#333';
  for(const w of walls){
    ctx.fillStyle = '#222';
    ctx.fillRect(w.x, w.y, w.w, w.h);
    ctx.strokeStyle = '#2b2b2b';
    ctx.strokeRect(w.x, w.y, w.w, w.h);
  }
  // draw bolas
  for(const b of bolas){
    ctx.beginPath();
    ctx.fillStyle = b.cor;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();
    // small outline
    ctx.strokeStyle = '#00000055';
    ctx.stroke();
  }
  // draw enemies
  enemies.forEach(en=>{
    ctx.beginPath();
    ctx.fillStyle = '#ff6b6b';
    ctx.arc(en.x,en.y,en.r,0,Math.PI*2);
    ctx.fill();
    // eye or indicator
    ctx.fillStyle = '#111';
    ctx.fillRect(en.x-6,en.y-4,4,4);
  });
  // draw projectiles
  projectiles.forEach(p=>{
    ctx.beginPath();
    ctx.fillStyle = '#ffd166';
    ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.fill();
  });
  // draw player
  ctx.beginPath();
  ctx.fillStyle = player.color;
  ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
  ctx.fill();
  // name
  ctx.fillStyle = '#fff';
  ctx.font = '12px sans-serif';
  ctx.fillText(player.name, player.x - ctx.measureText(player.name).width/2, player.y - player.r - 10);
}

/* -----------------------------
   Main loop
   ----------------------------- */

let lastTime = performance.now();
function step(now){
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  // level progression: if time exceeded, increase level
  const elapsed = (now - levelStartTime)/1000;
  if(elapsed >= LEVEL_DURATION + (level-1)*5){ // slightly longer each level
    startLevel(level+1);
  }

  movePlayer(dt);
  moveBalls(dt);
  moveEnemies(dt);
  moveProjectiles(dt);
  handleCollisions();
  draw();
  updateHUD();

  requestAnimationFrame(step);
}

/* -----------------------------
   Start / init handlers
   ----------------------------- */

function initAndStart(){
  // set up sizes
  if(modoTela.value === 'full') setCanvasMode('full'); else setCanvasMode('fixed');

  // read player name and color
  player.name = nomeInput.value || 'Jogador';
  player.color = corSelect.value || 'white';
  // show joystick on mobiles
  if(/Mobi|Android/i.test(navigator.userAgent)) {
    joystickEl.style.display = 'block';
    usingVirtualJoystick = true;
  } else {
    joystickEl.style.display = 'none';
    usingVirtualJoystick = false;
  }

  telaInicio.style.display = 'none';
  canvas.style.display = 'block';
  // start only immediately in single-player; in multiplayer, wait for 'startGame'
  if (!window.multiplayer || !window.multiplayer.enabled) {
    startLevel(1);
    lastTime = performance.now();
    requestAnimationFrame(step);
  } else {
    statusEl.innerText = 'Aguardando todos ficarem prontos...';
  }
}

/* Joystick virtual events */
joystickEl.addEventListener('touchstart', e=>{
  e.preventDefault();
  const t = e.changedTouches[0];
  touchId = t.identifier;
}, {passive:false});

joystickEl.addEventListener('touchmove', e=>{
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier === touchId){
      const rect = joystickEl.getBoundingClientRect();
      let x = t.clientX - rect.left - rect.width/2;
      let y = t.clientY - rect.top - rect.height/2;
      const max = rect.width/2 - 10;
      const dist = Math.hypot(x,y);
      if(dist > max){
        x = x * max / dist; y = y * max / dist;
      }
      stickEl.style.transform = `translate(${x}px, ${y}px)`;
      touchMove.x = x / max;
      touchMove.y = y / max;
    }
  }
}, {passive:false});

joystickEl.addEventListener('touchend', e=>{
  for(const t of e.changedTouches){
    if(t.identifier === touchId){
      touchId = null;
      touchMove.x = 0; touchMove.y = 0;
      stickEl.style.transform = `translate(0px, 0px)`;
    }
  }
});

/* Ensure touch on canvas doesn't scroll page */
canvas.addEventListener('touchmove', e=> e.preventDefault(), {passive:false});

/* start button */
btnStart.addEventListener('click', ()=>{
  initAndStart();
});

/* -----------------------------
   Helper: simple debug start for development
   ----------------------------- */

// startLevel(1) will be called when user clicks start

/* -----------------------------
   End of script
   ----------------------------- */

</script>

<!-- Multiplayer bridge: listens for messages from parent and sends messages to parent on events -->
<script>
(function(){
  // Notify parent when player scores or hits wrong color
  window.multiplayer = {
    enabled: false,
    roomId: null,
    name: null
  };

  window.addEventListener('message', (ev)=>{
    const data = ev.data;
    if(!data || !data.type) return;
    if(data.type === 'multiplayer-ready'){
      window.multiplayer.enabled = true;
      window.multiplayer.roomId = data.roomId;
      window.multiplayer.name = data.name || window.multiplayer.name;
      // Optionally show UI inside iframe
      console.log('Multiplayer enabled, room:', data.roomId);
    } else if(data.type === 'startGame'){
      // server says to start: reset and go
      const info = data.payload || {};
      score = 0;
      lives = info.startLives || START_LIVES;
      level = info.level || 1;
      // start loop if not already running
      startLevel(level);
      lastTime = performance.now();
      requestAnimationFrame(step);
      statusEl.innerText = '';
    } else if(data.type === 'roomUpdate'){
      // room status update from server
      console.log('roomUpdate from server', data.room);
      // you can show scoreboard etc.
    } else if(data.type === 'playerState'){
      // other player's state -- could render markers
      // data.player { id, state }
    }
  }, false);

  // expose function to send hits
  window.sendScoreHit = function(correct){
    if(window.parent) window.parent.postMessage({ type:'scoreHit', correct: !!correct }, '*');
  };

  // expose function to send state updates
  window.sendStateUpdate = function(state){
    if(window.parent) window.parent.postMessage({ type:'updateState', state }, '*');
  };

  // expose function to notify level advance
  window.sendAdvanceLevel = function(){
    if(window.parent) window.parent.postMessage({ type:'advanceLevel' }, '*');
  };

  // Example: if your game code calls window.onCorrectHit() or similar when player hits correct color,
  // you can call window.sendScoreHit(true) there. We'll try to hook into common function names if present.
  // If your game triggers custom events, adapt here.
  // For safety, we don't automatically override existing functions.
})();
</script>

</body>
</html>